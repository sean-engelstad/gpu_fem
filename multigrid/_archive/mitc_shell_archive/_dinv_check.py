import numpy as np

D1 = np.array([1.02137e+09,-1.82368e-17,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,-1.49012e-08,1.02137e+09,0.00000e+00,0.00000e+00,0.00000e+00,-9.15272e-02,0.00000e+00,0.00000e+00,1.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,2.34284e+06,1.76632e-17,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,4.11546e-11,2.34284e+06,0.00000e+00,0.00000e+00,-9.34829e+07,0.00000e+00,0.00000e+00,0.00000e+00,2.26047e+07])
Dinv1 = np.array([9.79079e-10,2.46137e-26,0.00000e+00,0.00000e+00,0.00000e+00,7.38412e-26,1.96910e-26,1.34968e-09,0.00000e+00,0.00000e+00,0.00000e+00,4.04903e-09,0.00000e+00,0.00000e+00,1.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,4.26832e-07,-7.53921e-24,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,-7.49778e-24,4.26832e-07,0.00000e+00,5.90730e-26,4.04903e-09,0.00000e+00,0.00000e+00,0.00000e+00,4.42385e-08])
D1, Dinv1 = D1.reshape((6,6)), Dinv1.reshape((6,6))
I1 = D1 @ Dinv1
# print(f"{D1=}\n{Dinv1=}")
# print(f"{I1=}")

# node 2 D vs Dinv
#         D_vals: 1.02137e+09,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,-9.15272e-02,0.00000e+00,1.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,1.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,2.34284e+06,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,1.00000e+00,0.00000e+00,-9.34829e+07,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,2.26047e+07,
#         Dinv_vals: 1.34968e-09,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,4.04903e-09,0.00000e+00,1.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,1.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,4.26832e-07,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,1.00000e+00,0.00000e+00,4.04903e-09,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,4.42385e-08,

D2 = np.array([1.02137e+09,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,-9.34829e+07,0.00000e+00,1.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,1.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,2.34284e+06,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,1.00000e+00,0.00000e+00,-9.34829e+07,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,3.11610e+07,])
Dinv2 = np.array([1.34968e-09,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,1.32716e-07,-0.00000e+00,1.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,-0.00000e+00,0.00000e+00,1.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,-0.00000e+00,0.00000e+00,0.00000e+00,4.26832e-07,0.00000e+00,0.00000e+00,-0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,1.00000e+00,0.00000e+00,1.23532e-10,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,4.42385e-08,])
D2, Dinv2 = D2.reshape((6,6)), Dinv2.reshape((6,6))
I2 = D2 @ Dinv2
# print(f"{D2=}\n{Dinv2=}")
# print(f"{I2=}")

Dinv2_true = np.linalg.inv(D2)
print(f"{Dinv2_true=}")

# try just using newton schulz here.. starting from identity.. see if that's better than the getriBatched
# X = np.eye(6)
def newton_schulz(M):
    X = np.diag(1.0 / np.diag(M))
    # X = np.zeros_like(M)
    for i in range(10):
        print(f"{X=}")

        X = X @ (2 * np.eye(M.shape[0]) - M @ X)
        I_check = M @ X - np.eye(M.shape[0])

        I_check_nrm = np.linalg.norm(I_check)
        print(f"{i=} {I_check_nrm=:.2e}")
    return X

M = np.random.rand(3,3) + 0.1 * np.eye(3) # + 2.0 * np.eye(3)
newton_schulz(M)